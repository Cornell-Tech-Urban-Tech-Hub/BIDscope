---
import Layout from '../../layouts/Default.astro';
import { getCollection } from 'astro:content';
import { Image } from 'astro:assets';
import MapVisualizer from '../../components/visualizations/MapVisualizer.js';
import fs from 'node:fs';
import path from 'node:path';
import '../../styles/projects.css';

// Define getStaticPaths to tell Astro which paths to generate
export async function getStaticPaths() {
  const projectEntries = await getCollection('projects');
  
  return projectEntries.map(entry => ({
    params: { slug: entry.slug },
    props: { entry },
  }));
}

// Get the project data from the props
const { entry } = Astro.props;
const { Content, headings } = await entry.render();

const base = import.meta.env.BASE_URL || '/';

// Get BID names from all projects for the map
const allProjects = await getCollection('projects');
const projectBids = allProjects.map(project => project.data.bidName);

// Check if this BID exists in the GeoJSON
let bidInMap = false;
let bidGeoData = null;
try {
  const geojsonPath = path.join(process.cwd(), 'public', 'data', 'bids.geojson');
  const geojsonData = JSON.parse(fs.readFileSync(geojsonPath, 'utf8'));
  const bidFeature = geojsonData.features.find(
    feature => feature.properties.F_ALL_BI_2 === entry.data.bidName
  );
  
  if (bidFeature) {
    bidInMap = true;
    bidGeoData = bidFeature;
  }
} catch (error) {
  console.error('Error loading BID map data:', error);
}

// Format date
function formatDate(date) {
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
}

console.log('REvision mode:', entry.data.revisionMode);

// Check for visualization components or revision mode
const isRevisionMode = entry.data.revisionMode === true;
const hasInsightViz = (entry.data.insightComponents && entry.data.insightComponents.length > 0) || isRevisionMode;
const hasTransformationViz = (entry.data.transformationComponents && entry.data.transformationComponents.length > 0) || isRevisionMode;
const hasPredictionViz = (entry.data.predictionComponents && entry.data.predictionComponents.length > 0) || isRevisionMode;
const hasConsensusViz = (entry.data.consensusComponents && entry.data.consensusComponents.length > 0) || isRevisionMode;

// Helper to create visualization section title icon
const getSectionIcon = (type) => {
  switch(type) {
    case 'insight':
      return `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>`;
    case 'transformation':
      return `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9h18v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9Z"/><path d="m3 9 2.45-4.9A2 2 0 0 1 7.24 3h9.52a2 2 0 0 1 1.8 1.1L21 9"/><path d="M12 3v6"/></svg>`;
    case 'prediction':
      return `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12h10"/><path d="M9 4v16"/><path d="M14 9l3 3-3 3"/><path d="M19 12h3"/></svg>`;
    case 'consensus':
      return `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 8h1a4 4 0 1 1 0 8h-1"/><path d="M3 8h14v9a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4Z"/><line x1="6" x2="6" y1="2" y2="4"/><line x1="10" x2="10" y1="2" y2="4"/><line x1="14" x2="14" y1="2" y2="4"/></svg>`;
    default:
      return '';
  }
};

// Detect section types in markdown content
const hasInsightSection = headings.some(h => h.text.toLowerCase().includes('insight'));
const hasTransformationSection = headings.some(h => h.text.toLowerCase().includes('transformation'));
const hasPredictionSection = headings.some(h => h.text.toLowerCase().includes('prediction'));
const hasConsensusSection = headings.some(h => h.text.toLowerCase().includes('consensus'));

// Import the raw markdown content so we can parse and inject components
const rawContent = await fs.promises.readFile(path.join(process.cwd(), 'src/content/projects', `${entry.slug}.md`), 'utf8');
const contentSections = {};

// Extract section content to inject visualization components
function extractSectionContent(content) {
  const sectionRegexes = {
    'insight': /## Insight Analysis[\s\S]*?(?=## \w+|$)/i,
    'transformation': /## Transformation Analysis[\s\S]*?(?=## \w+|$)/i,
    'prediction': /## Prediction Analysis[\s\S]*?(?=## \w+|$)/i, 
    'consensus': /## Consensus Analysis[\s\S]*?(?=## \w+|$)/i,
  };
  
  Object.keys(sectionRegexes).forEach(section => {
    const match = content.match(sectionRegexes[section]);
    if (match) {
      contentSections[section] = match[0];
    } else {
      contentSections[section] = '';
    }
  });
}

// Only try to extract sections if the file exists
if (fs.existsSync(path.join(process.cwd(), 'src/content/projects', `${entry.slug}.md`))) {
  extractSectionContent(rawContent);
}
---

<Layout 
  title={`${entry.data.title} | BIDSpec`}
  description={entry.data.description}
>
  <div class="container mx-auto px-4 py-12">
    <div class="mb-8">
      <a href={`${base}/projects`} class="text-primary hover:underline flex items-center gap-2">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"></path></svg>
        Back to Projects
      </a>
    </div>

    <article class="max-w-5xl mx-auto">
      <header class="project-header">
        <div class="flex items-center gap-2 text-muted-foreground text-sm mb-2">
          <span>{formatDate(entry.data.publishDate)}</span>
          <span>â€¢</span>
          <span class="bg-primary/10 text-primary px-2 py-1 rounded-full text-xs">{entry.data.borough}</span>
        </div>
        
        <h1 class="text-4xl font-bold mb-4">{entry.data.title}</h1>
        
        <div class="project-meta">
          <div class="project-meta-item">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="project-meta-icon"><path d="M3 3v18h18"/><path d="m19 9-5 5-4-4-3 3"/></svg>
            <span>{entry.data.bidName}</span>
            {bidInMap && (
              <span class="bg-primary/20 text-primary text-xs px-2 py-1 rounded-full ml-2">
                On Map
              </span>
            )}
          </div>
          
          {entry.data.yearEstablished && (
            <div class="project-meta-item">
              <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="project-meta-icon"><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></svg>
              <span>Established {entry.data.yearEstablished}</span>
            </div>
          )}
          
          {entry.data.tags && entry.data.tags.length > 0 && (
            <div class="project-meta-item flex-wrap">
              <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="project-meta-icon"><path d="M12 2H2v10l9.29 9.29c.94.94 2.48.94 3.42 0l6.58-6.58c.94-.94.94-2.48 0-3.42L12 2Z"/><path d="M7 7h.01"/></svg>
              <div class="flex flex-wrap gap-1 ml-1">
                {entry.data.tags.map(tag => (
                  <span class="bg-secondary text-secondary-foreground px-2 py-0.5 rounded text-xs">{tag}</span>
                ))}
              </div>
            </div>
          )}
        </div>
      </header>

      {isRevisionMode && (
        <div class="bg-yellow-100 border-l-4 border-yellow-500 p-4 mb-8 text-sm">
          <strong>Revision Mode Active:</strong> Placeholder visualization containers will be displayed in each section.
        </div>
      )}

      <!-- Map section moved to top, right after header -->
      <div class="mb-8 mt-4">
        <div class="border rounded-lg overflow-hidden shadow-md">
          <MapVisualizer 
            client:only="react"
            projectBids={projectBids} 
            focusBid={entry.data.bidName} 
            height="400px"
            initialZoom={14}
            disableLongPress={true}
          />
        </div>
      </div>

      <div id="project-content" class="project-content prose prose-lg max-w-none">
        <!-- Add a marker to indicate content is ready -->
        <div id="content-marker" data-revision-mode={isRevisionMode.toString()} style="display:none;"></div>
        
        <Content />
        
        <script>
          // Completely separate script execution from Astro's hydration
          (function() {
            // Get revision mode from the marker element to ensure correct value
            const contentMarker = document.getElementById('content-marker');
            const isRevisionMode = contentMarker ? contentMarker.getAttribute('data-revision-mode') === 'true' : false;
            
            // Check if visualizations have already been added
            let visualizationsAdded = false;
            
            // Function to initialize visualizations
            function initVisualizations() {
              if (visualizationsAdded) return;
              
              // Read component data from global window object (set below)
              const insightComponents = window.__projectData?.insightComponents || [];
              const transformationComponents = window.__projectData?.transformationComponents || [];
              const predictionComponents = window.__projectData?.predictionComponents || [];
              const consensusComponents = window.__projectData?.consensusComponents || [];
              
              // Determine which sections should have visualizations
              const hasInsightViz = insightComponents.length > 0 || isRevisionMode;
              const hasTransformationViz = transformationComponents.length > 0 || isRevisionMode;
              const hasPredictionViz = predictionComponents.length > 0 || isRevisionMode;
              const hasConsensusViz = consensusComponents.length > 0 || isRevisionMode;
              
              // First, check if we're in revision mode, if not and no components exist, exit
              if (!isRevisionMode && 
                  insightComponents.length === 0 && 
                  transformationComponents.length === 0 && 
                  predictionComponents.length === 0 && 
                  consensusComponents.length === 0) {
                return;
              }
              
              // Function to create visualization containers
              function createVisualizationContainer(component, index, title, isPlaceholder = false) {
                const container = document.createElement('div');
                container.className = 'viz-container mt-6 mb-8';
                
                const titleEl = document.createElement('h3');
                titleEl.className = 'viz-title';
                titleEl.textContent = `${title} Visualization ${index + 1}`;
                container.appendChild(titleEl);
                
                const frame = document.createElement('div');
                frame.className = 'viz-frame';
                
                const placeholder = document.createElement('div');
                placeholder.className = 'viz-placeholder';
                
                const text = document.createElement('p');
                
                if (isPlaceholder) {
                  text.innerHTML = `<strong>Revision Mode:</strong> Add ${title.toLowerCase()} visualization component here`;
                  placeholder.classList.add('draft-placeholder');
                } else {
                  text.textContent = `Visualization component: ${component}`;
                }
                
                placeholder.appendChild(text);
                frame.appendChild(placeholder);
                container.appendChild(frame);
                
                return container;
              }
              
              // More aggressive heading search
              function findHeadingElement(searchText) {
                // Try direct heading match first
                const allHeadings = Array.from(document.querySelectorAll('.project-content h1, .project-content h2'));
                
                // Look for exact matches first
                let heading = allHeadings.find(h => 
                  h.textContent.trim() === `${searchText} Analysis` || 
                  h.textContent.trim() === searchText
                );
                
                // If no exact match, try includes
                if (!heading) {
                  heading = allHeadings.find(h => 
                    h.textContent.toLowerCase().includes(searchText.toLowerCase())
                  );
                }
                
                return heading;
              }
              
              // Add visualization placeholders or components to each section
              function addVisualizationsToSection(sectionName, components, count = 2) {
                const heading = findHeadingElement(sectionName);
                
                if (!heading) {
                  console.warn(`Could not find heading for ${sectionName}`);
                  return;
                }
                
                // Create a wrapper for this section and insert after the heading
                const wrapper = document.createElement('div');
                wrapper.className = `${sectionName.toLowerCase()}-section-wrapper`;
                heading.after(wrapper);
                
                // Get the paragraph content that belongs to this section
                let currentElement = wrapper.nextElementSibling;
                const elementsToMove = [];
                
                // Collect all elements until the next heading
                while (currentElement && 
                      !currentElement.matches('h1, h2') && 
                      currentElement.tagName !== 'H1' && 
                      currentElement.tagName !== 'H2') {
                  elementsToMove.push(currentElement);
                  currentElement = currentElement.nextElementSibling;
                }
                
                // Move the elements into the wrapper
                elementsToMove.forEach(element => {
                  wrapper.appendChild(element);
                });
                
                // Add visualization row at the beginning of the section
                const vizRow = document.createElement('div');
                vizRow.className = 'viz-row';
                
                if (components.length > 0) {
                  components.forEach((component, index) => {
                    vizRow.appendChild(createVisualizationContainer(component, index, sectionName));
                  });
                } else if (isRevisionMode) {
                  for (let i = 0; i < count; i++) {
                    vizRow.appendChild(createVisualizationContainer('', i, sectionName, true));
                  }
                }
                
                if (vizRow.children.length > 0) {
                  // Insert at the beginning of the wrapper
                  wrapper.prepend(vizRow);
                }
              }
              
              // Add visualizations to each section
              if (hasInsightViz) {
                addVisualizationsToSection('Insight', insightComponents);
              }
              
              if (hasTransformationViz) {
                addVisualizationsToSection('Transformation', transformationComponents);
              }
              
              if (hasPredictionViz) {
                addVisualizationsToSection('Prediction', predictionComponents, 1);
              }
              
              if (hasConsensusViz) {
                addVisualizationsToSection('Consensus', consensusComponents);
              }
              
              visualizationsAdded = true;
              console.log('Visualizations added successfully');
            }
            
            // Astro content may need more time to render fully
            // Use a combination of techniques with increasing delays
            
            function attemptInit() {
              const contentEl = document.getElementById('project-content');
              const hasHeadings = document.querySelector('.project-content h1, .project-content h2');
              
              if (contentEl && hasHeadings) {
                initVisualizations();
              } else {
                // Set up a waiting strategy with multiple attempts
                console.log('Content or headings not ready, will retry');
                setupContentCheck();
              }
            }
            
            function setupContentCheck() {
              // Try multiple approaches with increasing delays
              const delays = [100, 300, 600, 1000, 2000]; // Milliseconds
              let attemptCount = 0;
              
              function checkAndInitialize() {
                const contentEl = document.getElementById('project-content');
                const hasHeadings = document.querySelector('.project-content h1, .project-content h2');
                
                if (contentEl && hasHeadings) {
                  initVisualizations();
                  return true;
                }
                
                if (attemptCount < delays.length) {
                  console.log(`Attempt ${attemptCount + 1} failed, trying again in ${delays[attemptCount]}ms`);
                  setTimeout(checkAndInitialize, delays[attemptCount]);
                  attemptCount++;
                  return false;
                }
                
                console.warn('Failed to find content after multiple attempts');
                return false;
              }
              
              checkAndInitialize();
            }
            
            // Start the process once DOM is initially loaded
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', attemptInit);
            } else {
              attemptInit();
            }
            
            // Also try on window load as a final attempt
            window.addEventListener('load', () => {
              if (!visualizationsAdded) {
                console.log('Trying initialization on window load');
                initVisualizations();
              }
            });
          })();
        </script>
        
        <script define:vars={{ 
          insightComponents: entry.data.insightComponents || [],
          transformationComponents: entry.data.transformationComponents || [],
          predictionComponents: entry.data.predictionComponents || [],
          consensusComponents: entry.data.consensusComponents || [],
        }}>
          // Store project data in a global object to avoid hydration issues
          window.__projectData = {
            insightComponents: insightComponents,
            transformationComponents: transformationComponents,
            predictionComponents: predictionComponents,
            consensusComponents: consensusComponents
          };
        </script>
      </div>

      {(entry.data.dataSource || (entry.data.visualizationTechniques && entry.data.visualizationTechniques.length > 0)) && (
        <div class="data-sources-panel">
          <h3 class="data-sources-title">Data & Methodology</h3>
          
          {entry.data.dataSource && (
            <div class="data-source-item">
              <h4 class="data-source-label">Data Sources</h4>
              <p>{entry.data.dataSource}</p>
            </div>
          )}
          
          {entry.data.visualizationTechniques && entry.data.visualizationTechniques.length > 0 && (
            <div class="data-source-item">
              <h4 class="data-source-label">Visualization Techniques</h4>
              <div class="technique-tags">
                {entry.data.visualizationTechniques.map(technique => (
                  <span class="technique-tag">{technique}</span>
                ))}
              </div>
            </div>
          )}
        </div>
      )}
    </article>
  </div>
</Layout>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const analysisHeaders = document.querySelectorAll('.analysis-header');
    
    const observerOptions = {
      threshold: 0.1,
      rootMargin: '0px 0px -100px 0px'
    };
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
          observer.unobserve(entry.target);
        }
      });
    }, observerOptions);
    
    analysisHeaders.forEach(header => {
      observer.observe(header);
    });
  });
</script>